/**
 * GDPR Service
 *
 * Handles GDPR/RGPD compliance operations:
 * - Processing activities registry (Art. 30)
 * - Data subject rights requests (Art. 15-22)
 * - Data export and portability (Art. 20)
 * - Consent management (Art. 7)
 * - Data retention policy
 * - Compliance reporting
 */

import { query } from '../database/supabase.js';
import logger from '../utils/logger.js';
// import PDFDocument from 'pdfkit'; // TODO: Uncomment when implementing PDF generation
import crypto from 'crypto';

/**
 * Request types for data subject rights
 */
export const REQUEST_TYPES = {
  ACCESS: 'access',              // Art. 15
  RECTIFICATION: 'rectification', // Art. 16
  ERASURE: 'erasure',            // Art. 17
  RESTRICTION: 'restriction',     // Art. 18
  PORTABILITY: 'portability',    // Art. 20
  OBJECTION: 'objection'         // Art. 21
};

/**
 * Request status
 */
export const REQUEST_STATUS = {
  PENDING: 'pending',
  IN_PROGRESS: 'in_progress',
  COMPLETED: 'completed',
  REJECTED: 'rejected',
  EXPIRED: 'expired'
};

/**
 * Legal bases for data processing
 */
export const LEGAL_BASES = {
  CONSENT: 'consent',
  CONTRACT: 'contract',
  LEGAL_OBLIGATION: 'legal_obligation',
  VITAL_INTERESTS: 'vital_interests',
  PUBLIC_INTEREST: 'public_interest',
  LEGITIMATE_INTERESTS: 'legitimate_interests'
};

// ============================================
// PROCESSING ACTIVITIES REGISTRY (Art. 30)
// ============================================

/**
 * Get all processing activities from the registry
 *
 * @param {Object} options - Filter options
 * @returns {Promise<Array>} List of processing activities
 */
export async function getProcessingActivitiesRegistry(options = {}) {
  try {
    const { isActive = true } = options;

    let sql = `
      SELECT
        id,
        activity_name,
        purpose,
        description,
        data_categories,
        data_subjects,
        legal_basis,
        recipients,
        international_transfers,
        transfer_safeguards,
        retention_period,
        security_measures,
        dpo_contact,
        is_active,
        created_at,
        updated_at
      FROM gdpr_processing_activities
    `;

    if (isActive !== null) {
      sql += ` WHERE is_active = ${isActive}`;
    }

    sql += ` ORDER BY activity_name ASC`;

    const result = await query(sql);
    return result.rows;
  } catch (error) {
    logger.error('Error fetching processing activities registry:', error);
    throw new Error('Failed to fetch processing activities');
  }
}

/**
 * Get data categories
 *
 * @returns {Promise<Array>} List of data categories
 */
export async function getDataCategories() {
  try {
    const result = await query(`
      SELECT
        id,
        category_name,
        description,
        legal_basis,
        retention_period,
        is_sensitive,
        data_examples,
        security_measures,
        created_at
      FROM gdpr_data_categories
      ORDER BY category_name ASC
    `);

    return result.rows;
  } catch (error) {
    logger.error('Error fetching data categories:', error);
    throw new Error('Failed to fetch data categories');
  }
}

/**
 * Get retention policy summary
 *
 * @returns {Promise<Object>} Retention policy information
 */
export async function getRetentionPolicy() {
  try {
    const categories = await getDataCategories();

    return {
      categories: categories.map(cat => ({
        category: cat.category_name,
        description: cat.description,
        retentionPeriod: cat.retention_period,
        legalBasis: cat.legal_basis,
        isSensitive: cat.is_sensitive
      })),
      lastUpdated: new Date().toISOString()
    };
  } catch (error) {
    logger.error('Error fetching retention policy:', error);
    throw new Error('Failed to fetch retention policy');
  }
}

// ============================================
// DATA SUBJECT RIGHTS REQUESTS (Art. 15-22)
// ============================================

/**
 * Create a new data subject request
 *
 * @param {Object} requestData - Request details
 * @returns {Promise<Object>} Created request
 */
export async function createDataRequest(requestData) {
  try {
    const {
      requesterEmail,
      requesterName,
      requestType,
      details,
      userId = null,
      ipAddress = null,
      userAgent = null
    } = requestData;

    // Validate request type
    if (!Object.values(REQUEST_TYPES).includes(requestType)) {
      throw new Error('Invalid request type');
    }

    // Generate request number (will be auto-generated by trigger, but we provide empty string)
    const requestNumber = '';

    const result = await query(`
      INSERT INTO gdpr_data_requests (
        request_number,
        requester_email,
        requester_name,
        request_type,
        status,
        details,
        user_id,
        ip_address,
        user_agent
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING *
    `, [
      requestNumber,
      requesterEmail,
      requesterName,
      requestType,
      REQUEST_STATUS.PENDING,
      details,
      userId,
      ipAddress,
      userAgent
    ]);

    // Log the action
    await logGDPRAudit({
      actionType: 'data_request_created',
      entityType: 'gdpr_data_request',
      entityId: result.rows[0].id,
      userId,
      details: { requestType, email: requesterEmail },
      ipAddress,
      userAgent
    });

    logger.info(`GDPR data request created: ${result.rows[0].request_number}`);

    return result.rows[0];
  } catch (error) {
    logger.error('Error creating data request:', error);
    throw new Error('Failed to create data request');
  }
}

/**
 * Get all data requests with optional filters
 *
 * @param {Object} filters - Filter options
 * @returns {Promise<Array>} List of requests
 */
export async function getDataRequests(filters = {}) {
  try {
    const {
      status,
      requestType,
      requesterEmail,
      limit = 100,
      offset = 0
    } = filters;

    let sql = `
      SELECT
        r.*,
        u.name as completed_by_name,
        u.email as completed_by_email
      FROM gdpr_data_requests r
      LEFT JOIN users u ON r.completed_by = u.id
      WHERE 1=1
    `;

    const params = [];
    let paramCount = 1;

    if (status) {
      sql += ` AND r.status = $${paramCount}`;
      params.push(status);
      paramCount++;
    }

    if (requestType) {
      sql += ` AND r.request_type = $${paramCount}`;
      params.push(requestType);
      paramCount++;
    }

    if (requesterEmail) {
      sql += ` AND r.requester_email ILIKE $${paramCount}`;
      params.push(`%${requesterEmail}%`);
      paramCount++;
    }

    sql += ` ORDER BY r.requested_at DESC`;
    sql += ` LIMIT $${paramCount} OFFSET $${paramCount + 1}`;
    params.push(limit, offset);

    const result = await query(sql, params);
    return result.rows;
  } catch (error) {
    logger.error('Error fetching data requests:', error);
    throw new Error('Failed to fetch data requests');
  }
}

/**
 * Get a single data request by ID
 *
 * @param {string} requestId - Request ID
 * @returns {Promise<Object>} Request details
 */
export async function getDataRequestById(requestId) {
  try {
    const result = await query(`
      SELECT
        r.*,
        u.name as completed_by_name,
        u.email as completed_by_email
      FROM gdpr_data_requests r
      LEFT JOIN users u ON r.completed_by = u.id
      WHERE r.id = $1
    `, [requestId]);

    if (result.rows.length === 0) {
      throw new Error('Request not found');
    }

    return result.rows[0];
  } catch (error) {
    logger.error('Error fetching data request:', error);
    throw error;
  }
}

/**
 * Update data request status
 *
 * @param {string} requestId - Request ID
 * @param {Object} updateData - Update details
 * @returns {Promise<Object>} Updated request
 */
export async function updateDataRequest(requestId, updateData) {
  try {
    const {
      status,
      response,
      rejectionReason,
      completedBy,
      ipAddress,
      userAgent
    } = updateData;

    const fields = [];
    const values = [];
    let paramCount = 1;

    if (status) {
      fields.push(`status = $${paramCount}`);
      values.push(status);
      paramCount++;
    }

    if (response) {
      fields.push(`response = $${paramCount}`);
      values.push(response);
      paramCount++;
    }

    if (rejectionReason) {
      fields.push(`rejection_reason = $${paramCount}`);
      values.push(rejectionReason);
      paramCount++;
    }

    if (status === REQUEST_STATUS.COMPLETED || status === REQUEST_STATUS.REJECTED) {
      fields.push(`completed_at = CURRENT_TIMESTAMP`);
      if (completedBy) {
        fields.push(`completed_by = $${paramCount}`);
        values.push(completedBy);
        paramCount++;
      }
    }

    if (fields.length === 0) {
      throw new Error('No fields to update');
    }

    values.push(requestId);

    const result = await query(`
      UPDATE gdpr_data_requests
      SET ${fields.join(', ')}
      WHERE id = $${paramCount}
      RETURNING *
    `, values);

    // Log the action
    await logGDPRAudit({
      actionType: 'data_request_processed',
      entityType: 'gdpr_data_request',
      entityId: requestId,
      userId: completedBy,
      details: { status, response: response?.substring(0, 100) },
      ipAddress,
      userAgent
    });

    logger.info(`GDPR data request updated: ${requestId} - Status: ${status}`);

    return result.rows[0];
  } catch (error) {
    logger.error('Error updating data request:', error);
    throw new Error('Failed to update data request');
  }
}

// ============================================
// DATA EXPORT & PORTABILITY (Art. 20)
// ============================================

/**
 * Export user data for data portability
 *
 * @param {string} userId - User ID
 * @param {string} format - Export format (json, csv)
 * @returns {Promise<Object>} Exported data
 */
export async function exportUserData(userId, format = 'json') {
  try {
    // Get user data
    const userData = await query(`
      SELECT id, email, name, role, created_at
      FROM users
      WHERE id = $1
    `, [userId]);

    if (userData.rows.length === 0) {
      throw new Error('User not found');
    }

    const user = userData.rows[0];

    // Get elections created by user
    const electionsData = await query(`
      SELECT
        id, title, description, status,
        start_date, end_date, created_at
      FROM elections
      WHERE created_by = $1
      ORDER BY created_at DESC
    `, [userId]);

    // Get audit logs
    const auditLogs = await query(`
      SELECT
        action, details, ip_address, timestamp
      FROM audit_logs
      WHERE user_id = $1
      ORDER BY timestamp DESC
      LIMIT 100
    `, [userId]);

    // Get consents
    const consents = await query(`
      SELECT
        consent_type, consent_version, granted,
        granted_at, withdrawn_at
      FROM gdpr_consents
      WHERE user_id = $1
      ORDER BY created_at DESC
    `, [userId]);

    const exportData = {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        accountCreated: user.created_at
      },
      elections: electionsData.rows,
      auditLogs: auditLogs.rows,
      consents: consents.rows,
      exportedAt: new Date().toISOString(),
      exportFormat: format
    };

    // Log the export
    await logGDPRAudit({
      actionType: 'data_exported',
      entityType: 'user',
      entityId: userId,
      userId,
      details: { format, recordCount: electionsData.rows.length }
    });

    logger.info(`User data exported: ${userId}`);

    if (format === 'csv') {
      return convertToCSV(exportData);
    }

    return exportData;
  } catch (error) {
    logger.error('Error exporting user data:', error);
    throw new Error('Failed to export user data');
  }
}

/**
 * Handle data access request (Art. 15)
 *
 * @param {string} requestId - Request ID
 * @param {string} userId - User ID making the request
 * @returns {Promise<Object>} User data
 */
export async function handleDataAccessRequest(requestId, userId) {
  try {
    const request = await getDataRequestById(requestId);

    if (request.request_type !== REQUEST_TYPES.ACCESS) {
      throw new Error('Not an access request');
    }

    // Export user data
    const userData = await exportUserData(userId, 'json');

    // Update request status
    await updateDataRequest(requestId, {
      status: REQUEST_STATUS.COMPLETED,
      response: 'Data access request fulfilled. Data exported.',
      completedBy: userId
    });

    return userData;
  } catch (error) {
    logger.error('Error handling data access request:', error);
    throw error;
  }
}

/**
 * Handle data erasure request (Art. 17)
 *
 * @param {string} requestId - Request ID
 * @param {string} userId - User ID
 * @param {Object} options - Erasure options
 * @returns {Promise<Object>} Result
 */
export async function handleDataErasureRequest(requestId, userId, options = {}) {
  try {
    const request = await getDataRequestById(requestId);

    if (request.request_type !== REQUEST_TYPES.ERASURE) {
      throw new Error('Not an erasure request');
    }

    // Check if user can be deleted (no legal obligation to keep)
    const activeElections = await query(`
      SELECT COUNT(*) as count
      FROM elections
      WHERE created_by = $1 AND status = 'active'
    `, [userId]);

    if (activeElections.rows[0].count > 0) {
      throw new Error('Cannot delete user with active elections');
    }

    // Anonymize or delete user data based on retention policy
    const { fullDeletion = false } = options;

    if (fullDeletion) {
      // Full deletion (only if no legal obligation)
      await query(`DELETE FROM users WHERE id = $1`, [userId]);
    } else {
      // Anonymization (keep for legal/audit purposes)
      await query(`
        UPDATE users
        SET
          email = CONCAT('deleted_', id, '@anonymized.local'),
          name = 'Deleted User',
          password = '',
          two_factor_enabled = false,
          two_factor_secret = NULL,
          two_factor_backup_codes = NULL
        WHERE id = $1
      `, [userId]);
    }

    // Update request
    await updateDataRequest(requestId, {
      status: REQUEST_STATUS.COMPLETED,
      response: fullDeletion ? 'User data fully deleted' : 'User data anonymized',
      completedBy: userId
    });

    // Log the deletion
    await logGDPRAudit({
      actionType: 'data_deleted',
      entityType: 'user',
      entityId: userId,
      userId,
      details: { fullDeletion, requestId }
    });

    logger.info(`User data ${fullDeletion ? 'deleted' : 'anonymized'}: ${userId}`);

    return {
      success: true,
      method: fullDeletion ? 'deletion' : 'anonymization'
    };
  } catch (error) {
    logger.error('Error handling data erasure request:', error);
    throw error;
  }
}

// ============================================
// CONSENT MANAGEMENT (Art. 7)
// ============================================

/**
 * Record user consent
 *
 * @param {Object} consentData - Consent details
 * @returns {Promise<Object>} Recorded consent
 */
export async function recordConsent(consentData) {
  try {
    const {
      userId,
      consentType,
      consentVersion,
      consentText,
      purpose,
      granted,
      ipAddress,
      userAgent,
      metadata = {}
    } = consentData;

    const result = await query(`
      INSERT INTO gdpr_consents (
        user_id,
        consent_type,
        consent_version,
        consent_text,
        purpose,
        granted,
        granted_at,
        ip_address,
        user_agent,
        metadata
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      RETURNING *
    `, [
      userId,
      consentType,
      consentVersion,
      consentText,
      purpose,
      granted,
      granted ? new Date().toISOString() : null,
      ipAddress,
      userAgent,
      JSON.stringify(metadata)
    ]);

    // Log the action
    await logGDPRAudit({
      actionType: 'consent_granted',
      entityType: 'gdpr_consent',
      entityId: result.rows[0].id,
      userId,
      details: { consentType, granted },
      ipAddress,
      userAgent
    });

    logger.info(`Consent recorded for user ${userId}: ${consentType} - ${granted ? 'granted' : 'denied'}`);

    return result.rows[0];
  } catch (error) {
    logger.error('Error recording consent:', error);
    throw new Error('Failed to record consent');
  }
}

/**
 * Withdraw consent
 *
 * @param {string} consentId - Consent ID
 * @param {string} userId - User ID
 * @returns {Promise<Object>} Updated consent
 */
export async function withdrawConsent(consentId, userId) {
  try {
    const result = await query(`
      UPDATE gdpr_consents
      SET
        granted = false,
        withdrawn_at = CURRENT_TIMESTAMP
      WHERE id = $1 AND user_id = $2
      RETURNING *
    `, [consentId, userId]);

    if (result.rows.length === 0) {
      throw new Error('Consent not found');
    }

    // Log the action
    await logGDPRAudit({
      actionType: 'consent_withdrawn',
      entityType: 'gdpr_consent',
      entityId: consentId,
      userId,
      details: { consentType: result.rows[0].consent_type }
    });

    logger.info(`Consent withdrawn: ${consentId}`);

    return result.rows[0];
  } catch (error) {
    logger.error('Error withdrawing consent:', error);
    throw new Error('Failed to withdraw consent');
  }
}

/**
 * Get consent history for a user
 *
 * @param {string} userId - User ID
 * @returns {Promise<Array>} Consent history
 */
export async function getConsentHistory(userId) {
  try {
    const result = await query(`
      SELECT *
      FROM gdpr_consents
      WHERE user_id = $1
      ORDER BY created_at DESC
    `, [userId]);

    return result.rows;
  } catch (error) {
    logger.error('Error fetching consent history:', error);
    throw new Error('Failed to fetch consent history');
  }
}

// ============================================
// RETENTION POLICY & DATA CLEANUP
// ============================================

/**
 * Enforce retention policy (delete or anonymize old data)
 *
 * @returns {Promise<Object>} Cleanup results
 */
export async function enforceRetentionPolicy() {
  try {
    const results = {
      electionsAnonymized: 0,
      votersDeleted: 0,
      observersDeleted: 0,
      auditLogsArchived: 0
    };

    // Anonymize old closed elections (> 5 years)
    const fiveYearsAgo = new Date();
    fiveYearsAgo.setFullYear(fiveYearsAgo.getFullYear() - 5);

    const oldElections = await query(`
      UPDATE elections
      SET
        description = 'Election archived - description removed per retention policy',
        is_weighted = false,
        quorum_type = NULL,
        quorum_value = NULL
      WHERE status = 'closed'
        AND end_date < $1
      RETURNING id
    `, [fiveYearsAgo.toISOString()]);

    results.electionsAnonymized = oldElections.rows.length;

    // Delete old voters (> 1 year after election end)
    const oneYearAgo = new Date();
    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);

    const oldVoters = await query(`
      DELETE FROM voters
      WHERE election_id IN (
        SELECT id FROM elections
        WHERE status = 'closed' AND end_date < $1
      )
      RETURNING id
    `, [oneYearAgo.toISOString()]);

    results.votersDeleted = oldVoters.rows.length;

    // Delete old observers (> 6 months after election end)
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

    const oldObservers = await query(`
      DELETE FROM observers
      WHERE election_id IN (
        SELECT id FROM elections
        WHERE status = 'closed' AND end_date < $1
      )
      RETURNING id
    `, [sixMonthsAgo.toISOString()]);

    results.observersDeleted = oldObservers.rows.length;

    // Log the cleanup
    await logGDPRAudit({
      actionType: 'retention_applied',
      entityType: 'system',
      entityId: 'retention_policy',
      details: results
    });

    logger.info('Retention policy enforced:', results);

    return results;
  } catch (error) {
    logger.error('Error enforcing retention policy:', error);
    throw new Error('Failed to enforce retention policy');
  }
}

// ============================================
// COMPLIANCE REPORTING
// ============================================

/**
 * Generate compliance statistics
 *
 * @returns {Promise<Object>} Compliance stats
 */
export async function getComplianceStatistics() {
  try {
    // Get request statistics
    const requestStats = await query(`
      SELECT
        request_type,
        status,
        COUNT(*) as count
      FROM gdpr_data_requests
      GROUP BY request_type, status
    `);

    // Get consent statistics
    const consentStats = await query(`
      SELECT * FROM gdpr_consents_summary
    `);

    // Get active requests summary
    const activeRequests = await query(`
      SELECT * FROM gdpr_active_requests_summary
    `);

    // Get processing activities count
    const activitiesCount = await query(`
      SELECT
        COUNT(*) as total,
        SUM(CASE WHEN is_active THEN 1 ELSE 0 END) as active
      FROM gdpr_processing_activities
    `);

    return {
      requests: requestStats.rows,
      consents: consentStats.rows,
      activeRequests: activeRequests.rows,
      processingActivities: activitiesCount.rows[0],
      generatedAt: new Date().toISOString()
    };
  } catch (error) {
    logger.error('Error generating compliance statistics:', error);
    throw new Error('Failed to generate compliance statistics');
  }
}

// ============================================
// AUDIT LOGGING
// ============================================

/**
 * Log GDPR-specific action
 *
 * @param {Object} logData - Log details
 */
export async function logGDPRAudit(logData) {
  try {
    const {
      actionType,
      entityType,
      entityId,
      userId = null,
      details = {},
      ipAddress = null,
      userAgent = null
    } = logData;

    await query(`
      INSERT INTO gdpr_audit_log (
        action_type,
        entity_type,
        entity_id,
        user_id,
        details,
        ip_address,
        user_agent
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7)
    `, [
      actionType,
      entityType,
      entityId,
      userId,
      JSON.stringify(details),
      ipAddress,
      userAgent
    ]);
  } catch (error) {
    logger.error('Error logging GDPR audit:', error);
    // Don't throw - logging shouldn't break main operations
  }
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

/**
 * Convert data to CSV format
 *
 * @param {Object} data - Data to convert
 * @returns {string} CSV string
 */
function convertToCSV(data) {
  // Simple CSV conversion for user data
  const lines = [];

  // Header
  lines.push('Type,ID,Email,Name,Created At');

  // User data
  lines.push(`User,${data.user.id},${data.user.email},${data.user.name},${data.user.accountCreated}`);

  // Elections
  data.elections.forEach(election => {
    lines.push(`Election,${election.id},"${election.title}",${election.status},${election.created_at}`);
  });

  return lines.join('\n');
}

export default {
  // Registry
  getProcessingActivitiesRegistry,
  getDataCategories,
  getRetentionPolicy,

  // Requests
  createDataRequest,
  getDataRequests,
  getDataRequestById,
  updateDataRequest,
  handleDataAccessRequest,
  handleDataErasureRequest,

  // Data export
  exportUserData,

  // Consents
  recordConsent,
  withdrawConsent,
  getConsentHistory,

  // Retention
  enforceRetentionPolicy,

  // Reporting
  getComplianceStatistics,

  // Audit
  logGDPRAudit
};
