/**
 * CSRF Protection Middleware
 * Prevents Cross-Site Request Forgery attacks
 *
 * Uses double-submit cookie pattern:
 * - Token stored in HTTP-only cookie
 * - Token also sent in request header/body
 * - Server verifies they match
 */

import crypto from 'crypto';

// In-memory token store (in production, use Redis or database)
const tokenStore = new Map();

// Clean up old tokens every hour
setInterval(() => {
  const now = Date.now();
  let cleaned = 0;

  for (const [token, data] of tokenStore.entries()) {
    if (now - data.createdAt > 3600000) { // 1 hour
      tokenStore.delete(token);
      cleaned++;
    }
  }

  if (cleaned > 0) {
    console.log(`[CSRF] Cleaned ${cleaned} expired tokens`);
  }
}, 3600000); // Run every hour

/**
 * Generate a new CSRF token
 * @returns {string} Random token
 */
function generateToken() {
  return crypto.randomBytes(32).toString('hex');
}

/**
 * Middleware to generate and set CSRF token in cookie
 * Call on login/page load
 */
export const csrfTokenGeneration = (req, res, next) => {
  try {
    // Generate new token
    const token = generateToken();

    // Store token with creation time
    tokenStore.set(token, {
      createdAt: Date.now(),
      userId: req.user?.id,
      sessionId: req.sessionID
    });

    // Set as HTTP-only cookie (secure in production)
    res.cookie('XSRF-TOKEN', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 3600000, // 1 hour
      path: '/'
    });

    // Also send token in response body for client to use in headers
    res.csrfToken = token;

    next();
  } catch (error) {
    console.error('[CSRF] Token generation error:', error);
    next(error);
  }
};

/**
 * Middleware to verify CSRF token
 * Call on state-changing requests (POST, PUT, DELETE, PATCH)
 */
export const csrfTokenVerification = (req, res, next) => {
  // Skip GET, HEAD, OPTIONS requests
  if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {
    return next();
  }

  try {
    // Get token from request
    // Try multiple sources: header, body, cookie
    const token =
      req.headers['x-csrf-token'] ||
      req.headers['x-xsrf-token'] ||
      req.body?.csrfToken ||
      req.query?.csrfToken;

    if (!token) {
      return res.status(403).json({
        error: true,
        code: 'CSRF_TOKEN_MISSING',
        message: 'CSRF token manquant. Veuillez recharger la page.'
      });
    }

    // Verify token exists in store
    const tokenData = tokenStore.get(token);
    if (!tokenData) {
      return res.status(403).json({
        error: true,
        code: 'CSRF_TOKEN_INVALID',
        message: 'CSRF token invalide ou expiré. Veuillez recharger la page.'
      });
    }

    // Optional: Verify token belongs to current user/session
    if (tokenData.userId && tokenData.userId !== req.user?.id) {
      return res.status(403).json({
        error: true,
        code: 'CSRF_TOKEN_MISMATCH',
        message: 'CSRF token ne correspond pas à l\'utilisateur'
      });
    }

    // Token is valid, remove it from store (single use)
    tokenStore.delete(token);

    // Generate new token for next request
    const newToken = generateToken();
    tokenStore.set(newToken, {
      createdAt: Date.now(),
      userId: req.user?.id,
      sessionId: req.sessionID
    });

    // Send new token in response headers
    res.setHeader('X-New-CSRF-Token', newToken);
    res.cookie('XSRF-TOKEN', newToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 3600000,
      path: '/'
    });

    next();
  } catch (error) {
    console.error('[CSRF] Token verification error:', error);
    res.status(500).json({
      error: true,
      code: 'CSRF_VERIFICATION_ERROR',
      message: 'Erreur lors de la vérification du CSRF token'
    });
  }
};

/**
 * Middleware to provide CSRF token in response
 * Useful for endpoints that return forms or pages
 */
export const csrfTokenProvider = (req, res, next) => {
  // If token already generated by csrfTokenGeneration, send it
  if (res.csrfToken) {
    return res.json({
      token: res.csrfToken,
      message: 'CSRF token generated'
    });
  }

  // Otherwise generate one
  const token = generateToken();
  tokenStore.set(token, {
    createdAt: Date.now(),
    userId: req.user?.id
  });

  res.cookie('XSRF-TOKEN', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 3600000,
    path: '/'
  });

  res.json({
    token,
    message: 'CSRF token generated'
  });
};

/**
 * Utility function to get CSRF token from request
 */
export function getCsrfToken(req) {
  return req.headers['x-csrf-token'] ||
         req.headers['x-xsrf-token'] ||
         req.body?.csrfToken ||
         req.query?.csrfToken ||
         req.cookies?.['XSRF-TOKEN'];
}

/**
 * Clear CSRF tokens for a user (on logout)
 */
export function clearUserTokens(userId) {
  let cleared = 0;
  for (const [token, data] of tokenStore.entries()) {
    if (data.userId === userId) {
      tokenStore.delete(token);
      cleared++;
    }
  }
  return cleared;
}

/**
 * Get token store stats (for monitoring)
 */
export function getTokenStats() {
  return {
    totalTokens: tokenStore.size,
    memoryUsage: JSON.stringify(Array.from(tokenStore)).length
  };
}

export default {
  csrfTokenGeneration,
  csrfTokenVerification,
  csrfTokenProvider,
  getCsrfToken,
  clearUserTokens,
  getTokenStats
};
